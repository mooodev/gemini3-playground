<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LADA 2107 Drift - Enhanced 3D Physics</title>
    <style>
        /* Base styles */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            color: white;
        }
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
        }
        
        /* UI container */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
        }
        h1 { 
            margin: 0; 
            font-size: 24px; 
            color: #ff9900; 
        }
        p { 
            margin: 5px 0; 
            color: #ccc; 
            font-size: 16px; 
        }
        .key { 
            color: #00ffff; 
            font-weight: bold; 
        }
        
        /* Drift Angle Indicator (Conceptual Feedback) */
        #drift-angle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px; /* Made slightly smaller for clean look */
            height: 100px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.4);
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            color: #ffcc00;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
            pointer-events: none;
        }
        #drift-angle span {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
    </style>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Inflate dependency for FBXLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/inflate.min.js"></script>
    <!-- FBX Loader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
</head>
<body>

<div id="ui">
    <h1>LADA 2107 DRIFT üõ†Ô∏è</h1>
    <p><span class="key">WASD</span> to Drive | <span class="key">SPACE</span> to Handbrake</p>
    <p id="speed">0 KM/H</p>
    <p id="slide-val">Slide: 0</p>
</div>

<!-- Drift Angle Indicator -->
<div id="drift-angle">
    <span id="angle-value">0¬∞</span>
    <span>DRIFT ANGLE</span>
</div>


<script>
    // --- GLOBAL VARIABLES ---
    let scene, camera, renderer;
    let carGroup, carBody; 
    let wheels = [];
    let skidmarks = [];
    let tlL, tlR; // Taillight meshes
    let matTailOff, matBrakeOn; // Brake light materials

    // --- SMOKE PARTICLE SYSTEM VARIABLES ---
    let smokeParticles = [];
    const maxSmokeParticles = 300;
    
    // Physics State
    let pos = { x: 0, z: 0 };
    let vel = { x: 0, z: 0 }; // Global Velocity
    let angle = 0; // Facing direction
    
    // Configuration
    const CONFIG = {
        accel: 0.6,
        reverse: 0.025,
        turnSpeed: 0.05,
        drag: 0.97,
        grip: 0.15,
        // Conceptual Improvement: Reduced grip drastically when handbrake is used
        drift: 0.85, 
        tilt: 0.015 // Increased tilt for visual feedback
    };

    // Input State
    const keys = { w: false, a: false, s: false, d: false, space: false };

    // --- SMOKE TEXTURE AND MATERIAL ---
    function createSmokeTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        
        // Radial gradient for a soft, round appearance (Visual Structural Improvement)
        const gradient = ctx.createRadialGradient(
            canvas.width / 2, canvas.height / 2, 0, 
            canvas.width / 2, canvas.height / 2, canvas.width / 2
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        return new THREE.CanvasTexture(canvas);
    }

    const smokeMaterial = new THREE.SpriteMaterial({ 
        color: 0xaaaaaa, // Lighter grey for better smoke visibility
        transparent: true, 
        opacity: 0.8, 
        map: createSmokeTexture(), 
        blending: THREE.AdditiveBlending,
        depthWrite: false 
    });

    function init() {
        // 1. SCENE
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101015);
        // Structural Improvement: Add dark fog for atmosphere
        scene.fog = new THREE.FogExp2(0x101015, 0.001); 

        // 2. CAMERA
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 70, -100); 

        // 3. RENDERER
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // Structural Improvement: Tone Mapping for contrast
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);
        
        // 4. LIGHTING
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, -100);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        const d = 500;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.bias = -0.001;
        scene.add(dirLight);

        // 5. ENVIRONMENT (Structural Improvement: Stylized ground)
        const planeGeo = new THREE.PlaneGeometry(10000, 10000);
        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x151515, 
            roughness: 0.9, 
            metalness: 0.1 
        });
        const ground = new THREE.Mesh(planeGeo, planeMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid remains as a structural reference
        const grid = new THREE.GridHelper(10000, 200, 0x333333, 0x1a1a1a);
        grid.position.y = 0.1;
        scene.add(grid);

        // 6. BUILD CAR
        createLada();

        // 7. LISTENERS
        window.addEventListener('resize', onResize);
        window.addEventListener('keydown', (e) => updateKey(e, true));
        window.addEventListener('keyup', (e) => updateKey(e, false));

        // 8. START
        animate();
    }

    function createLada() {
        carGroup = new THREE.Group();
        scene.add(carGroup);

        // --- CAR BODY GROUP (Handles Tilt) ---
        carBody = new THREE.Group();
        carGroup.add(carBody);

        // Load the FBX model using a CORS proxy to avoid CORS issues
        const proxyUrl = 'https://api.allorigins.win/raw?url=';
        const modelUrl = 'https://raw.githubusercontent.com/mooodev/tools/main/images/Lada.fbx';
        const loader = new THREE.FBXLoader();
        loader.load(proxyUrl + encodeURIComponent(modelUrl), (object) => {
            object.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Calculate bounding box to scale and position the model
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3());
            const targetLength = 44; // Match original primitive model length (assuming z-axis)
            const scaleFactor = targetLength / size.z;
            object.scale.set(scaleFactor, scaleFactor, scaleFactor);

            // Update box after scaling
            box.setFromObject(object);

            // Position so that the bottom touches the ground
            object.position.y = -box.min.y;

            carBody.add(object);
        }, undefined, function (error) {
            console.error(error);
        });
    }

    function updateKey(e, state) {
        const k = e.key.toLowerCase();
        if (k === 'w' || k === 'arrowup') keys.w = state;
        if (k === 's' || k === 'arrowdown') keys.s = state;
        if (k === 'a' || k === 'arrowleft') keys.a = state;
        if (k === 'd' || k === 'arrowright') keys.d = state;
        if (k === ' ') keys.space = state;
    }

    // --- SKIDMARK FUNCTIONS ---
    function addSkidmark(x, z, rot, slide) {
        if (Math.abs(slide) < 0.5) return; // Only draw if sliding significantly
        
        const geo = new THREE.PlaneGeometry(12, 3); 
        const opacity = Math.min(Math.abs(slide)/30, 0.4); 
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0x0a0a0a, 
            opacity: opacity, 
            transparent: true, 
            side: THREE.DoubleSide, 
            depthWrite: false 
        });
        const m = new THREE.Mesh(geo, mat);
        
        m.rotation.x = -Math.PI / 2;
        m.rotation.z = rot;
        m.position.set(x, 0.05, z); 
        
        scene.add(m);
        skidmarks.push({ mesh: m, life: 1000 }); 
    }

    function updateSkidmarks() {
        for (let i = skidmarks.length - 1; i >= 0; i--) {
            let s = skidmarks[i];
            s.life--;
            s.mesh.material.opacity *= 0.999; 
            if (s.life <= 0) {
                scene.remove(s.mesh);
                skidmarks.splice(i, 1);
            }
        }
    }

    // --- SMOKE PARTICLE FUNCTIONS (FIXED: Takes slideVal as argument) ---
    function addSmokeParticle(x, z, rot, slideVal) {
        // Optimization: don't emit if not sliding enough
        if (Math.abs(slideVal) < 0.5) return; 
        
        const wheelOffsetZ = 14; 
        const wheelOffsetX = 10.5;

        // Use slideVal for scaling particle emission (Conceptual Improvement)
        const slideFactor = Math.abs(slideVal) / 5; 

        // Calculate the world position of the rear wheels
        const rearL_x = x + Math.sin(rot) * -wheelOffsetZ + Math.cos(rot) * -wheelOffsetX;
        const rearL_z = z + Math.cos(rot) * -wheelOffsetZ - Math.sin(rot) * -wheelOffsetX;

        const rearR_x = x + Math.sin(rot) * -wheelOffsetZ + Math.cos(rot) * wheelOffsetX;
        const rearR_z = z + Math.cos(rot) * -wheelOffsetZ - Math.sin(rot) * wheelOffsetX;

        // Generate particles near both rear wheels
        [
            { x: rearL_x, z: rearL_z }, 
            { x: rearR_x, z: rearR_z }
        ].forEach(p => {
            if (smokeParticles.length >= maxSmokeParticles) return;
            if (Math.random() > 0.4) return; 

            const size = Math.random() * 5 + 3 + slideFactor; 
            const sprite = new THREE.Sprite(smokeMaterial.clone());
            
            sprite.position.set(p.x + Math.random() * 1.5 - 0.75, 1, p.z + Math.random() * 1.5 - 0.75);
            sprite.scale.set(size, size, size);
            sprite.material.opacity = 0.4 + Math.random() * 0.3; 
            
            scene.add(sprite);
            smokeParticles.push({
                mesh: sprite,
                life: 60 + Math.random() * 60, 
                startLife: 60,
                // Give particles slight sideways/backward velocity (smoke trail)
                vx: (Math.random() * 0.2 - 0.1) * slideFactor, 
                vz: (Math.random() * 0.2 - 0.1) * slideFactor
            });
        });
    }

    function updateSmokeParticles() {
        for (let i = smokeParticles.length - 1; i >= 0; i--) {
            let p = smokeParticles[i];
            
            p.mesh.position.y += 0.05; 
            p.mesh.position.x += p.vx;
            p.mesh.position.z += p.vz;
            
            p.life--;

            const lifeRatio = p.life / p.startLife;
            p.mesh.material.opacity = Math.max(0, lifeRatio) * 0.6; 
            p.mesh.scale.multiplyScalar(1.02); 

            if (p.life <= 0) {
                scene.remove(p.mesh);
                smokeParticles.splice(i, 1);
            }
        }
    }


    function animate() {
        requestAnimationFrame(animate);

        // --- 1. CALCULATE PHYSICS ---
        const sin = Math.sin(angle);
        const cos = Math.cos(angle);

        let fwdVel = (vel.x * sin) + (vel.z * cos);
        let sideVel = (vel.x * cos) - (vel.z * sin); // This is the variable that caused the error

        if (keys.w) fwdVel += CONFIG.accel;
        if (keys.s) fwdVel -= CONFIG.reverse;

        if (Math.abs(fwdVel) > 0.1) {
            const dir = fwdVel > 0 ? 1 : -1; 
            if (keys.a) angle += CONFIG.turnSpeed * dir;
            if (keys.d) angle -= CONFIG.turnSpeed * dir;
        }

        fwdVel *= CONFIG.drag;
        
        // Handbrake logic
        const sideFriction = keys.space ? CONFIG.drift : CONFIG.grip;
        sideVel *= sideFriction;

        vel.x = (sin * fwdVel) + (cos * sideVel);
        vel.z = (cos * fwdVel) - (sin * sideVel);

        pos.x += vel.x;
        pos.z += vel.z;

        // --- 2. UPDATE VISUALS ---
        
        carGroup.position.set(pos.x, 0, pos.z);
        carGroup.rotation.y = angle;

        // Car Body Tilt (Structural Improvement: More pronounced visual lean)
        carBody.rotation.z = -sideVel * CONFIG.tilt; 
        carBody.rotation.x = -fwdVel * 0.005; 

        // Skidmarks and Smoke Generation (Conceptual Feedback)
        const isDrifting = Math.abs(sideVel) > 0.5 || keys.space;

        if (isDrifting) {
            if(Math.abs(fwdVel) > 0.5) { 
                const wheelOffset = 10.5;
                // Rear Left Wheel Skidmark
                addSkidmark(pos.x - Math.sin(angle + Math.PI/2) * wheelOffset, pos.z - Math.cos(angle + Math.PI/2) * wheelOffset, angle, sideVel);
                // Rear Right Wheel Skidmark
                addSkidmark(pos.x + Math.sin(angle + Math.PI/2) * wheelOffset, pos.z + Math.cos(angle + Math.PI/2) * wheelOffset, angle, sideVel);
                
                // FIXED: Passing sideVel as an argument to addSmokeParticle
                addSmokeParticle(pos.x, pos.z, angle, sideVel);
            }
        }
        updateSkidmarks();
        updateSmokeParticles();

        // Structural Improvement: Smoother Camera Follow
        const camDist = 80;
        const camHeight = 30;
        
        const targetX = pos.x - Math.sin(angle) * camDist;
        const targetZ = pos.z - Math.cos(angle) * camDist;
        
        const smoothFactor = 0.08; 

        camera.position.x += (targetX - camera.position.x) * smoothFactor;
        camera.position.z += (targetZ - camera.position.z) * smoothFactor;
        camera.position.y += (camHeight - camera.position.y) * smoothFactor;
        camera.lookAt(pos.x, 0, pos.z);

        // UI Updates (Conceptual Feedback)
        const currentSpeed = Math.floor(Math.abs(fwdVel * 5));
        const driftAngle = Math.floor(Math.abs(sideVel) * 20); // Scale the slide value for the UI
        
        document.getElementById('speed').innerText = `${currentSpeed} KM/H`;
        document.getElementById('slide-val').innerText = `Slide: ${driftAngle.toFixed(0)}`;
        
        // Highlight the drift angle if actively drifting
        const angleElement = document.getElementById('angle-value');
        angleElement.innerText = `${driftAngle}¬∞`;
        angleElement.style.color = driftAngle > 10 ? '#ff4444' : '#ffcc00';


        renderer.render(scene, camera);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Initialize the application
    window.onload = init; 
</script>
</body>
</html>
